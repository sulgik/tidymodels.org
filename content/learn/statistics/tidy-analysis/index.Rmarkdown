---
title: "상관도와 회귀의 기초사항에 관한 타이디한 데이터 원칙"
tags: [broom]
categories: [statistical analysis]
type: learn-subsection
weight: 1
description: | 
  상관검정과 단순 회귀모델의 결과 분석을 여러 데이터셋에 대해 동시에 수행한다.
---

```{r setup, include = FALSE, message = FALSE, warning = FALSE}
source(here::here("content/learn/common.R"))
```

```{r load, include = FALSE}
library(tidymodels)
pkgs <- c("tidymodels")
theme_set(theme_bw() + theme(legend.position = "top"))
```

## 들어가기

이 장은 tidymodels 패키지만 필요로 합니다.

tidymodels 패키지인 [broom](https://broom.tidyverse.org/) 패키지가 단일 분석 결과를 일관성있는 형태로 요약하는데 유용하지만, 여러 분석결과를 합쳐야하는 high-throuput 을 위해 고안된 것입니다.
합쳐지는 것들은 데이터의 서브그룹, 다른 모델을 사용한 분석들, bootstrap replicates, permutations 등이 될 수 있습니다. 
특별이 이 패키지는 [tidyr](https://tidyr.tidyverse.org/) 의 `nest()/unnest()` 함수들, [purrr](https://purrr.tidyverse.org/) 의 `map()` 함수와 잘 작동합니다.

## 상관 분석

빌트인 데이터셋 `Orange` 으로 한번 살펴봅시다. 
`Orange` 를 `tibble` 로 강제변환하는 것부터 시작해봅시다. 
이렇게하면 더 나은 print 메소드를 제공하는데, 이는 나중에 리스트컬럼으로 작업하기 시작할 때 매우 유용하게 될 것입니다.

```{r}
library(tidymodels)

data(Orange)

Orange <- as_tibble(Orange)
Orange
```

35 개의 관측값들이 다음 3 개의 변수들을 가지고 있습니다: `Tree`, `age`, `circumference`. `Tree` 는 각각 다섯 나무를 의미하는 레벨 가진 팩터형입니다. 예상했듯이, 나이와 둘레길이는 상관관계가 있습니다:

```{r}
cor(Orange$age, Orange$circumference)

library(ggplot2)

ggplot(Orange, aes(age, circumference, color = Tree)) +
  geom_line()
```

각 나무 *내(within)* 에서 개별적으로 상관관계가 있는지 테스트하고 싶다고 하자. 
dplyr 의 `group_by` 으로 할 수 있다:

```{r}
Orange %>% 
  group_by(Tree) %>%
  summarize(correlation = cor(age, circumference))
```

(Note that the correlations are much higher than the aggregated one, and also we can now see the correlation is similar across trees).

Suppose that instead of simply estimating a correlation, we want to perform a hypothesis test with `cor.test()`:

```{r}
ct <- cor.test(Orange$age, Orange$circumference)
ct
```

This test output contains multiple values we may be interested in. Some are vectors of length 1, such as the p-value and the estimate, and some are longer, such as the confidence interval. We can get this into a nicely organized tibble using the `tidy()` function:

```{r}
tidy(ct)
```

Often, we want to perform multiple tests or fit multiple models, each on a different part of the data. In this case, we recommend a `nest-map-unnest` workflow. For example, suppose we want to perform correlation tests for each different tree. We start by `nest`ing our data based on the group of interest:

```{r}
nested <- 
  Orange %>% 
  nest(data = c(age, circumference))
```

Then we perform a correlation test for each nested tibble using `purrr::map()`:

```{r}
nested %>% 
  mutate(test = map(data, ~ cor.test(.x$age, .x$circumference)))
```

This results in a list-column of S3 objects. We want to tidy each of the objects, which we can also do with `map()`.

```{r}
nested %>% 
  mutate(
    test = map(data, ~ cor.test(.x$age, .x$circumference)), # S3 list-col
    tidied = map(test, tidy)
  ) 
```

Finally, we want to unnest the tidied data frames so we can see the results in a flat tibble. All together, this looks like:

```{r}
Orange %>% 
  nest(data = c(age, circumference)) %>% 
  mutate(
    test = map(data, ~ cor.test(.x$age, .x$circumference)), # S3 list-col
    tidied = map(test, tidy)
  ) %>% 
  unnest(cols = tidied) %>% 
  select(-data, -test)
```

## 회귀 모델

This type of workflow becomes even more useful when applied to regressions. Untidy output for a regression looks like:

```{r}
lm_fit <- lm(age ~ circumference, data = Orange)
summary(lm_fit)
```

When we tidy these results, we get multiple rows of output for each model:

```{r}
tidy(lm_fit)
```

Now we can handle multiple regressions at once using exactly the same workflow as before:

```{r}
Orange %>%
  nest(data = c(-Tree)) %>% 
  mutate(
    fit = map(data, ~ lm(age ~ circumference, data = .x)),
    tidied = map(fit, tidy)
  ) %>% 
  unnest(tidied) %>% 
  select(-data, -fit)
```

You can just as easily use multiple predictors in the regressions, as shown here on the `mtcars` dataset. We nest the data into automatic vs. manual cars (the `am` column), then perform the regression within each nested tibble.

```{r}
data(mtcars)
mtcars <- as_tibble(mtcars)  # to play nicely with list-cols
mtcars

mtcars %>%
  nest(data = c(-am)) %>% 
  mutate(
    fit = map(data, ~ lm(wt ~ mpg + qsec + gear, data = .x)),  # S3 list-col
    tidied = map(fit, tidy)
  ) %>% 
  unnest(tidied) %>% 
  select(-data, -fit)
```

What if you want not just the `tidy()` output, but the `augment()` and `glance()` outputs as well, while still performing each regression only once? Since we're using list-columns, we can just fit the model once and use multiple list-columns to store the tidied, glanced and augmented outputs.

```{r}
regressions <- 
  mtcars %>%
  nest(data = c(-am)) %>% 
  mutate(
    fit = map(data, ~ lm(wt ~ mpg + qsec + gear, data = .x)),
    tidied = map(fit, tidy),
    glanced = map(fit, glance),
    augmented = map(fit, augment)
  )

regressions %>% 
  select(tidied) %>% 
  unnest(tidied)

regressions %>% 
  select(glanced) %>% 
  unnest(glanced)

regressions %>% 
  select(augmented) %>% 
  unnest(augmented)
```

By combining the estimates and p-values across all groups into the same tidy data frame (instead of a list of output model objects), a new class of analyses and visualizations becomes straightforward. This includes:

- sorting by p-value or estimate to find the most significant terms across all tests,
- p-value histograms, and
- volcano plots comparing p-values to effect size estimates.

In each of these cases, we can easily filter, facet, or distinguish based on the `term` column. In short, this makes the tools of tidy data analysis available for the *results* of data analysis and models, not just the inputs.


## Session information

```{r si, echo = FALSE}
small_session(pkgs)
```

